<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guess Mode Test Suite</title>
    <style>
        body { font-family: monospace; padding: 20px; }
        .test-results { margin: 20px 0; }
        .test-pass { color: green; }
        .test-fail { color: red; }
        .test-info { color: blue; }
        .test-section { border: 1px solid #ccc; margin: 10px 0; padding: 10px; }
    </style>
</head>
<body>
    <h1>Chess Guess Mode Test Suite</h1>
    <div id="testResults"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script>
        class GuessModeTester {
            constructor() {
                this.results = [];
                this.stockfish = null;
                this.testPositions = [
                    {
                        fen: 'rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1',
                        description: 'Opening position after 1.e4',
                        expectedBestMoves: ['d7d5', 'e7e5', 'g8f6', 'b8c6'], // Common good responses
                        testMoves: [
                            { move: 'd7d5', expectedQuality: 'excellent' },
                            { move: 'e7e5', expectedQuality: 'excellent' },
                            { move: 'g8f6', expectedQuality: 'good' },
                            { move: 'a7a6', expectedQuality: 'poor' }
                        ]
                    },
                    {
                        fen: 'rnbqkbnr/ppp1pppp/8/3p4/4P3/8/PPPP1PPP/RNBQKBNR w KQkq d6 0 2',
                        description: 'After 1.e4 d5',
                        expectedBestMoves: ['e4d5', 'b1c3', 'd2d3'],
                        testMoves: [
                            { move: 'e4d5', expectedQuality: 'excellent' },
                            { move: 'b1c3', expectedQuality: 'good' },
                            { move: 'h2h3', expectedQuality: 'poor' }
                        ]
                    }
                ];
            }

            log(message, type = 'info') {
                const div = document.getElementById('testResults');
                const p = document.createElement('p');
                p.className = `test-${type}`;
                p.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                div.appendChild(p);
                console.log(message);
            }

            async initializeStockfish() {
                return new Promise((resolve, reject) => {
                    try {
                        this.stockfish = new Worker('/stockfish-nnue-16.js');
                        
                        this.stockfish.onmessage = (event) => {
                            const message = event.data;
                            if (message.includes('uciok')) {
                                this.stockfish.postMessage('setoption name Threads value 1');
                                this.stockfish.postMessage('setoption name Hash value 64');
                                this.stockfish.postMessage('ucinewgame');
                                this.stockfish.postMessage('isready');
                            } else if (message.includes('readyok')) {
                                resolve();
                            }
                        };

                        this.stockfish.onerror = (error) => {
                            reject(error);
                        };

                        this.stockfish.postMessage('uci');
                    } catch (error) {
                        reject(error);
                    }
                });
            }

            async analyzePosition(fen) {
                return new Promise((resolve, reject) => {
                    let bestMove = null;
                    let evaluation = null;
                    let depth = 0;
                    const timeout = setTimeout(() => {
                        reject(new Error('Analysis timeout'));
                    }, 10000);

                    const messageHandler = (event) => {
                        const message = event.data;
                        
                        if (message.includes('info') && message.includes('depth')) {
                            const parts = message.split(' ');
                            for (let i = 0; i < parts.length; i++) {
                                if (parts[i] === 'depth') {
                                    depth = parseInt(parts[i + 1]);
                                } else if (parts[i] === 'score' && parts[i + 1] === 'cp') {
                                    evaluation = parseInt(parts[i + 2]) / 100;
                                } else if (parts[i] === 'pv') {
                                    bestMove = parts[i + 1];
                                    break;
                                }
                            }
                        } else if (message.startsWith('bestmove')) {
                            clearTimeout(timeout);
                            this.stockfish.onmessage = null;
                            resolve({ bestMove, evaluation, depth });
                        }
                    };

                    this.stockfish.onmessage = messageHandler;
                    this.stockfish.postMessage(`position fen ${fen}`);
                    this.stockfish.postMessage('go depth 12 movetime 3000');
                });
            }

            async evaluateMove(fen, moveUci) {
                const game = new Chess(fen);
                const from = moveUci.substring(0, 2);
                const to = moveUci.substring(2, 4);
                const promotion = moveUci.length > 4 ? moveUci.substring(4, 5) : undefined;
                
                const move = game.move({ from, to, promotion });
                if (!move) {
                    return { evaluation: null, legal: false };
                }

                try {
                    const analysis = await this.analyzePosition(game.fen());
                    return { evaluation: analysis.evaluation, legal: true };
                } catch (error) {
                    return { evaluation: null, legal: true, error: error.message };
                }
            }

            classifyMoveQuality(playerEval, bestEval, isBlackToMove) {
                // Adjust evaluations for perspective
                let adjustedPlayerEval = playerEval;
                let adjustedBestEval = bestEval;
                
                if (isBlackToMove) {
                    adjustedPlayerEval = -adjustedPlayerEval;
                    adjustedBestEval = -adjustedBestEval;
                }

                const evalDiff = Math.abs(adjustedPlayerEval - adjustedBestEval);
                
                if (evalDiff <= 0.1) return 'excellent';
                if (evalDiff <= 0.5) return 'good';
                if (evalDiff <= 1.0) return 'ok';
                return 'poor';
            }

            async testPosition(positionData) {
                this.log(`\n=== Testing Position: ${positionData.description} ===`, 'info');
                this.log(`FEN: ${positionData.fen}`, 'info');
                
                try {
                    // Analyze the position
                    const analysis = await this.analyzePosition(positionData.fen);
                    const { bestMove, evaluation } = analysis;
                    
                    this.log(`Engine Best Move: ${bestMove}`, 'info');
                    this.log(`Engine Evaluation: ${evaluation}`, 'info');
                    
                    const game = new Chess(positionData.fen);
                    const isBlackToMove = game.turn() === 'b';
                    
                    // Test if the best move is in our expected list
                    const bestMoveExpected = positionData.expectedBestMoves.includes(bestMove);
                    if (bestMoveExpected) {
                        this.log(`✓ Best move is expected`, 'pass');
                    } else {
                        this.log(`⚠ Best move ${bestMove} not in expected list: ${positionData.expectedBestMoves.join(', ')}`, 'fail');
                    }

                    // Test each move
                    for (const testMove of positionData.testMoves) {
                        this.log(`\n--- Testing move: ${testMove.move} ---`, 'info');
                        
                        const moveResult = await this.evaluateMove(positionData.fen, testMove.move);
                        
                        if (!moveResult.legal) {
                            this.log(`✗ Move ${testMove.move} is illegal`, 'fail');
                            continue;
                        }
                        
                        if (moveResult.error) {
                            this.log(`✗ Error evaluating ${testMove.move}: ${moveResult.error}`, 'fail');
                            continue;
                        }

                        const quality = this.classifyMoveQuality(moveResult.evaluation, evaluation, isBlackToMove);
                        
                        this.log(`Move ${testMove.move}: eval=${moveResult.evaluation?.toFixed(2)}, quality=${quality}`, 'info');
                        
                        if (quality === testMove.expectedQuality) {
                            this.log(`✓ Move quality matches expected: ${quality}`, 'pass');
                        } else {
                            this.log(`✗ Move quality mismatch: expected ${testMove.expectedQuality}, got ${quality}`, 'fail');
                        }
                    }
                    
                } catch (error) {
                    this.log(`✗ Error testing position: ${error.message}`, 'fail');
                }
            }

            async runAllTests() {
                this.log('=== Starting Chess Guess Mode Test Suite ===', 'info');
                
                try {
                    this.log('Initializing Stockfish...', 'info');
                    await this.initializeStockfish();
                    this.log('✓ Stockfish initialized', 'pass');
                    
                    for (const positionData of this.testPositions) {
                        await this.testPosition(positionData);
                    }
                    
                    this.log('\n=== Test Suite Complete ===', 'info');
                    
                } catch (error) {
                    this.log(`✗ Test suite failed: ${error.message}`, 'fail');
                }
            }
        }

        // Auto-run tests when page loads
        window.addEventListener('load', () => {
            const tester = new GuessModeTester();
            tester.runAllTests();
        });
    </script>
</body>
</html>